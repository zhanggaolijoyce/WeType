import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';  
import ArrowCircleLeftIcon from '@mui/icons-material/ArrowCircleLeft';
import RestartAltIcon from '@mui/icons-material/RestartAlt';  
import IconButton from '@mui/material/IconButton';
import Button from '@mui/material/Button';
import LinearProgress from '@mui/material/LinearProgress';
import Typography from '@mui/material/Typography';
import Box from '@mui/material/Box';
import Tooltip from '@mui/material/Tooltip';
import TextSample from '../../components/TextSample';
import axios from 'axios';
import './styles.css';
import Dialog from '@mui/material/Dialog';
import DialogTitle from '@mui/material/DialogTitle';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogActions from '@mui/material/DialogActions';
import fetchGeneratedText from '../../api'; // 假设您的API调用函数在这个文件中



const api_url = "http://localhost:3000/graphql";

async function graphQLFetch(query, variables = {}) {
    try {
      const response = await fetch(api_url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json'},
        body: JSON.stringify({ query, variables })
      });
      const body = await response.text();
      if(body == null)
        return null;
      const result = JSON.parse(body);
      /*
      Check for errors in the GraphQL response
      */
      if (result.errors) {
        const error = result.errors[0];
        if (error.extensions.code == 'BAD_USER_INPUT') {
          const details = error.extensions.exception.errors.join('\n ');
          alert(`${error.message}:\n ${details}`);
        } else {
          alert(`${error.extensions.code}: ${error.message}`);
        }
      }
      return result.data;
    } catch (e) {
      alert(`Error in sending data to server: ${e.message}`);
    }
  } 

function LinearProgressWithLabel(props) {
    const { timeLabel, color, ...otherProps } = props;

    return (
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Box sx={{ width: '100%', mr: 1 }}>
                <LinearProgress 
                    variant="determinate" 
                    {...otherProps} 
                    sx={{
                        width: '500px',  
                        height: '50px',
                        backgroundColor: 'white', // Set the background color of the progress bar to white
                        '& .MuiLinearProgress-bar': {
                            backgroundColor: color, // Use the incoming color attribute
                        },
                    }}
                />
            </Box>
            <Box sx={{ width: 50, ml: 3 }}>    {/* Increase the left margin to 3 (adjust as needed)） */}
                <Typography 
                    variant="h6"                     /* Change variant to h6 or set fontSize */
                    color="text.secondary"
                    sx={{
                        letterSpacing: '-0.05em',  // Negative values will bring letters closer, while positive values are the opposite.
                        fontWeight: 'bold'
                    }}
                >
                    {timeLabel || `${Math.round(otherProps.value)}%`}
                </Typography>
            </Box>
        </Box>
    );
}

// Create an auxiliary function to unify text encoding
function normalizeText(text) {
    return text
        .replace(/’/g, "'") // 将右单引号替换为标准单引号
        .replace(/‘/g, "'") // 将左单引号替换为标准单引号
        .replace(/“/g, '"') // 将左双引号替换为标准双引号
        .replace(/”/g, '"') // 将右双引号替换为标准双引号
}

function formatGeneratedText(text) {
    // Remove spaces and line breaks at the beginning and end
    let formattedText = text.trim();
  
    // Replace all line breaks and extra spaces with one space
    formattedText = formattedText.replace(/\s+/g, ' ');
  
    return formattedText;
  }
  

function PracticeYourself( {theme} ) {
    const email = useLocation().state.email;
    const [textType, setTextType] = useState('News'); // New state to store text types
    const [generatedText, setGeneratedText] = useState(''); // New state to store the text generated by the API
    const [isTextLoaded, setIsTextLoaded] = useState(false); // New state variables
    const [totalChars, setTotalChars] = useState(0);


    const [typingTime, setTypingTime] = useState(120);  // 2 minute as the default
    const [textAreaContent, setTextAreaContent] = useState(''); // get the typed content
    const [correctChars, setCorrectChars] = useState(0);
    const navigate = useNavigate();
    const backButtonColor = theme === 'PinkGradient'  ? '#e27396' : '#007bff'; //Set the return key color according to the theme
    const [timeUpOpen, setTimeUpOpen] = useState(false);
    // Dynamically set the color of the progress bar according to the theme
    const progressBarColor = theme === 'PinkGradient' ? '#ea9ab2' : '#007bff';



    // 假设用户设定的时间为1分钟
    const prefer_time = 120;
    const [remainingTime, setRemainingTime] = useState(prefer_time);

    async function countCommonCharsAtFront(str1, str2) {
        let commonCharsCount = 0;
        const minLength = Math.min(str1.length, str2.length);
      
        for (let i = 0; i < minLength; i++) {
          if (str1[i] === str2[i]) {
            commonCharsCount++;
          } else{
            break; //Stop counting when a mismatch is found
          }  
        }
        console.log("Str1:", str1);
        console.log("Str2:", str2);
        console.log("Common Chars Count:", commonCharsCount);
      
        return commonCharsCount;
    }

    const handleAddRecord = async (variables) => {
        console.log(variables);
        if(!variables.email){
            console.log("Error::addRecord::invalid email.");
            return;
        }
        if(!variables.time || !variables.words){
            console.log("Error::addRecord::invalid record.");
        }

        const addRecordMutation = `
            mutation addRecord($email: String!, $time: Int!, $words: Int!) {
                addRecord(email: $email, time: $time, words: $words) 
            }
        `;

        let response = 0;
        try{
            response = await graphQLFetch(addRecordMutation, variables);
            response = response.addRecord;
        } catch(error){
            console.log('Error::addRecord::', error);
            return;
        }

        if(response == 1){
            // success
            console.log("Log::addRecord::your practice has successfully been uploaded.");
        }
        else if(response == -1){
            console.log("Error::addRecord::user not found.");
            return;
        }
        else{
            console.log("Error::addRecord::practice upload unsuccessfully.");
            return;
        }
    }

    const handleTextAreaChange = async (event) => {
        // Update the state with the current content of the textarea
        const currentText = event.target.value;
        setTextAreaContent(currentText);
        // Use normalizeText function to process text
        const normalizedUserInput = normalizeText(currentText);
        const normalizedGeneratedText = normalizeText(generatedText);
        // Compare with processed text
        const num = await countCommonCharsAtFront(normalizedGeneratedText, normalizedUserInput);
        setCorrectChars(num);
        console.log("currentText:", currentText);
        console.log("generatedText:", generatedText);
        console.log("correctChars:", correctChars);
    };

    useEffect(() => {
        if (isTextLoaded && remainingTime > 0) {
            const timer = setTimeout(() => {
                setRemainingTime(remainingTime - 1);
            }, 1000);
            return () => clearTimeout(timer);
        } else if (remainingTime === 0){
            setTimeUpOpen(true); // Open the pop-up window when time is up 
        }
    }, [remainingTime, isTextLoaded]);

    useEffect(() => {
        const savedTextType = localStorage.getItem('textType'); // Get text types from local storage
        if (savedTextType) {
          setTextType(savedTextType);
        }
      }, []);

      useEffect(() => {
        if (textType) {
            fetchGeneratedText(textType).then(text => {
                const textString = formatGeneratedText(text.toString()); // Format text with formatGeneratedText function
                setGeneratedText(textString); // Store the text returned by the API
                console.log("Generated Text:", textString); 
                setTotalChars(textString.length); // Update the total number of characters
                setRemainingTime(prefer_time); // Start the countdown after getting the text
                setIsTextLoaded(true); // Set to true after loading
            });
        }
    }, [textType]);

    useEffect(() => {
        console.log("correctChars updated:", correctChars);
        // 这里可以添加基于 correctChars 更新的逻辑
        // 比如，您可以在这里调用 navigateToResult 或其他依赖于 correctChars 的函数
    }, [correctChars]); // 依赖项数组中包含 correctChars
    



    // Update the timer logic
    const progressPercentage = remainingTime === 0 ? 100 : ((prefer_time - remainingTime) / prefer_time) * 100;

    const handleRestart = () => {
        // Reset the remaining time to the preset time
        setRemainingTime(prefer_time);
        setTextAreaContent('');
    }
    

    const handleGoBack = () => {
        navigate("/home", { state: { email: email } });  // Navigate with the function
    }

    const handleTimeUpClose = () => {
        setTimeUpOpen(false);
        navigateToResult();
    };

    // Convert time to minutes: seconds format
    const formatTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
    }

    const generateColoredText = (text) => {
        const colors = ['#ffccd5', '#a6d7a1'];
        return text.split('').map((char, index) => (
            <span key={index} style={{ backgroundColor: index < 5 ? '#ffccd5' : index === 5 ? '#a6d7a1' : 'transparent', }}>{char}</span>
        ));
    };

    // Added jump function to show Result
    const navigateToResult = () => {
        const variables = {
            email: email,
            time: prefer_time - remainingTime,
            words: correctChars
        };
    
        handleAddRecord(variables);
    
        console.log("Navigating to Result with:", {
            email: email,
            time: prefer_time - remainingTime,
            correctChars: correctChars,
            totalChars: totalChars
        });
    
        navigate('/result-solo', { 
            state: { 
                email: email, 
                time: prefer_time - remainingTime, 
                correctChars: correctChars, 
                totalChars: totalChars 
            } 
        });
    };
    

    return (
        <div className="practice-container">
            <Dialog open={timeUpOpen} onClose={handleTimeUpClose}>
                <DialogTitle style={{ backgroundColor: '#f0f0f0' }}>Time's Up!</DialogTitle>
                <DialogContent style={{ backgroundColor: '#f8f8f8' }}>
                    <DialogContentText>
                        Your practice session has ended. Click OK to view the results.
                    </DialogContentText>
                </DialogContent>
                <DialogActions style={{ backgroundColor: '#f0f0f0' }}>
                    <Button onClick={handleTimeUpClose}>OK</Button>
                </DialogActions>
            </Dialog>

            <header>
            <Tooltip title="Back">
                <Button
                    startIcon={<ArrowCircleLeftIcon style={{ color: backButtonColor, fontSize: '2rem' }} />}  
                    onClick={handleGoBack}
                    className="arrow-left-icon"
                >
                </Button>
            </Tooltip>
                <h1 className="practice-title">Practice Solo</h1>
            </header>
            <div className="content">
                <div className="timer-container practice-timer-container">
                    <LinearProgressWithLabel 
                        value={progressPercentage} 
                        timeLabel={formatTime(remainingTime)} // 使用 remainingTime
                        color={progressBarColor} // 根据主题设置颜色
                    />
                    <Tooltip title="restart">
                        <IconButton onClick={handleRestart} className="restart-button">
                            <RestartAltIcon /> 
                        </IconButton>
                    </Tooltip>
                </div>
                <div className="text-sample">
                    {generatedText}
                </div>

                <div className="textarea-wrapper">
                    <textarea placeholder="Enter the text here...." value={textAreaContent} onChange={handleTextAreaChange}></textarea>
                </div>   

                <Button 
                    variant="contained" 
                    color="primary" 
                    onClick={navigateToResult}
                    style={{ marginTop: '20px' }} // 可以调整样式
                >
                    View the Result
                </Button>  
            </div>
        </div>
    );
}

export default PracticeYourself;
